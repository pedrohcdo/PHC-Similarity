<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHC Similarity Pipeline</title>
    <style>
        .main-container {
            width: 100%;
            overflow-x: auto;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #f4f4f4;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .pipeline {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            justify-content: flex-start;
        }

        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 200px;
            white-space: normal;
        }

        .list-container {
            overflow-y: auto;
            max-height: 200px;
            width: 100%;
        }

        .list-item {
            font-size: 0.9em;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding: 5px;
        }

        input[type="text"],
        input[type="range"],
        input[type="number"],
        button {
            width: 100%;
        }

        .arrow {
            font-size: 2em;
            user-select: none;
        }

        .pipeline-title,
        .github-repo-link {
            font-weight: bold;
            user-select: none;
        }

        .note {
            background-color: #fffbe5;
            border-left: 4px solid #fff200;
            padding: 5px;
            margin-top: 5px;
            font-size: 0.8em;
            color: #555;
            border-radius: 4px;
            max-width: 220px;
            word-wrap: break-word;
        }

        #thresholdContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .github-repo-link {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #eee;
            padding: 5px;
            border-radius: 5px;
            text-decoration: none;
            color: #333;
            z-index: 10;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        @media (max-width: 1700px) {
            .main-container {
                align-items: flex-start;
            }
        }
    </style>
</head>

<body>
    <div class="main-container">
        <div class="github-repo-link">
            <a href="https://github.com/pedrohcdo/PedroThermoDistance" target="_blank">Visit the GitHub Repo</a>
        </div>
        <div class="pipeline">
            <span class="pipeline-title">Pipeline</span>
            <span class="arrow">→</span>

            <!-- Initial Words -->
            <div class="container">
                <h3>Initial Words</h3>
                <input type="text" id="newWord" placeholder="Add new word">
                <button onclick="addWord()">Add Word</button>
                <div class="list-container" id="wordList"></div>
            </div>
            <span class="arrow">→</span>

            <!-- Comparison Settings -->
            <div class="container">
                <h3>PHC Similarity Settings</h3>
                <input type="text" id="comparisonText" placeholder="Comparison text" value="accordion">
                <div class="note">Enter a word or phrase to compare against the initial list.</div>

                <label for="penaltyClamp">Penalty Clamp: <span id="clampValue">3</span></label>
                <input type="range" id="penaltyClamp" min="1" max="5" value="3"
                    oninput="document.getElementById('clampValue').textContent = value">
                <div class="note">Adjust the maximum limit for penalty scaling. This clamp value sets the upper bound
                    for how much the penalty can increase with each subsequent mismatch.</div>
            </div>
            <span class="arrow">→</span>

            <!-- All Words with Similarity -->
            <div class="container">
                <h3>All Words</h3>
                <div class="list-container" id="allWords"></div>
            </div>
            <span class="arrow">→</span>

            <!-- Threshold -->
            <div class="container" id="thresholdContainer">
                <label>Threshold:</label>
                <input type="number" id="threshold" value="0.5" min="0" max="1" step="0.01">
            </div>
            <span class="arrow">→</span>

            <!-- Filtered Words -->
            <div class="container">
                <h3>Filtered Words</h3>
                <div class="list-container" id="filteredWords"></div.
            </div>
        </div>
    </div>

    <script>
        const initialWords = [
            "accordion", "accordions", "accord", "accordanceeeeee", "accordant",
            "accorded", "accordionisttt", "accooooossssssteddd", "accounted", "accolade",
            "accccollllaaaades", "accoooooutttttter", "accoutrements", "accretion", "accreditation",
            "accrued", "accuuuuuuumulllllllate", "accurate", "accursed", "accusssation",
            "accusative", "accuuuuuusssssssatory", "accuse", "acccused", "accuser",
            "accccuuuuses", "accusing", "accccustom", "accustomed", "accustoming",
            "coordiiinate", "coordination", "coordinator", "coordinating", "acoustic",
            "acoooustics", "acolyte", "acolytes", "acorn", "acorns"
        ];

        const wordList = document.getElementById('wordList');
        const allWords = document.getElementById('allWords');
        const filteredWords = document.getElementById('filteredWords');

        // Initial populate of word list
        populateWordList(initialWords, wordList);
        updateAll()

        document.getElementById('newWord').addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                addWord();
            }
        });

        document.getElementById('comparisonText').addEventListener('input', updateAll);
        document.getElementById('penaltyClamp').addEventListener('input', updateAll);
        document.getElementById('threshold').addEventListener('input', updateAll);

        function addWord() {
            const newWordInput = document.getElementById('newWord');
            const newWord = newWordInput.value.trim();
            if (newWord) {
                initialWords.push(newWord);
                populateWordList(initialWords, wordList);
                newWordInput.value = ''; // Clear the input box
                updateAll(); // Update filtered words list
            }
        }

        function populateWordList(words, container) {
            container.innerHTML = words.map(word => `<div class="list-item">${word}</div>`).join('');
        }

        function updateAll() {
            updateAllWords()
            updateFilteredWords()
        }

        function updateAllWords() {
            const comparisonText = document.getElementById('comparisonText').value;
            const penaltyClamp = parseFloat(document.getElementById('penaltyClamp').value);
            
            allWords.innerHTML = initialWords
                .map(word => ({ word, similarity: calculateLocalSimilarity(word, comparisonText, penaltyClamp) }))
                .map(item => `<div class="list-item">${item.word} - ${(item.similarity * 100).toFixed(2)}%</div>`)
                .join('');
        }

        function updateFilteredWords() {
            const threshold = parseFloat(document.getElementById('threshold').value);
            const comparisonText = document.getElementById('comparisonText').value;
            const penaltyClamp = parseFloat(document.getElementById('penaltyClamp').value);

            filteredWords.innerHTML = initialWords
                .map(word => ({ word, similarity: calculateLocalSimilarity(word, comparisonText, penaltyClamp) }))
                .filter(item => item.similarity > threshold)
                .map(item => `<div class="list-item">${item.word} - ${(item.similarity * 100).toFixed(2)}%</div>`)
                .join('');
        }

        function calculateLocalSimilarity(firstText, secondText, penaltyClamp) {
            let ptd = PedroThermoDistance.from(firstText, secondText, penaltyClamp);
            return ptd.localSimilarity(1);
        }

        class PedroThermoDistance {
            constructor(firstText, secondText, thermometerSize, dp, options = { heating: 1, cooling: 1 }) {
                this.firstText = firstText;
                this.secondText = secondText;
                this.thermometerSize = thermometerSize;
                this.dp = dp;
                this.options = options;
            }
        
            static from(firstText, secondText, thermometerSize, options = { heating: 1, cooling: 1 }) {
                const thermometerWidth = thermometerSize * 2 + 1;
                const dp = Array.from({ length: firstText.length + 1 }, () =>
                    Array.from({ length: secondText.length + 1 }, () =>
                        Array.from({ length: thermometerWidth }, () => [0, 0])
                    )
                );
        
                for (let i = 1; i <= firstText.length; i++) {
                    for (let a = 0; a < thermometerWidth; a++) {
                        dp[i][0][a][0] = dp[i - 1][0][Math.max(a - (options.cooling), 0)][0] + (thermometerWidth - a);
                        dp[i][0][a][1] = dp[i - 1][0][Math.max(a - (options.cooling), 0)][1] + (thermometerWidth - a);
                    }
                }
        
                for (let j = 1; j <= secondText.length; j++) {
                    for (let a = 0; a < thermometerWidth; a++) {
                        dp[0][j][a][0] = dp[0][j - 1][Math.max(a - (options.cooling), 0)][0] + (thermometerWidth - a);
                        dp[0][j][a][1] = dp[0][j - 1][Math.max(a - (options.cooling), 0)][1] + (thermometerWidth - a);
                    }
                }
        
                for (let i = 0; i < firstText.length; i++) {
                    for (let j = 0; j < secondText.length; j++) {
                        for (let a = 0; a < thermometerWidth; a++) {
                            const cost = thermometerWidth - a;
                            const heat = Math.min(a + (options.heating), thermometerWidth - 1);
                            const cold = Math.max(a - (options.cooling), 0);
        
                            let cutsCandidatesLTR = [];
                            if (firstText.charAt(i) === secondText.charAt(j)) {
                                cutsCandidatesLTR.push(dp[i][j][heat][0]);
                            }
                            cutsCandidatesLTR.push(dp[i + 1][j][cold][0] + cost);
                            cutsCandidatesLTR.push(dp[i][j + 1][cold][0] + cost);
        
                            dp[i + 1][j + 1][a][0] = Math.min(...cutsCandidatesLTR);
        
                            let cutsCandidatesRTL = [];
                            if (firstText.charAt(firstText.length - i - 1) === secondText.charAt(secondText.length - j - 1)) {
                                cutsCandidatesRTL.push(dp[i][j][heat][1]);
                            }
                            cutsCandidatesRTL.push(dp[i + 1][j][cold][1] + cost);
                            cutsCandidatesRTL.push(dp[i][j + 1][cold][1] + cost);
        
                            dp[i + 1][j + 1][a][1] = Math.min(...cutsCandidatesRTL);
                        }
                    }
                }
        
                return new PedroThermoDistance(firstText, secondText, thermometerSize, dp, options);
            }
        
            get thermometerWidth() {
                return this.thermometerSize * 2 + 1;
            }
        
            traverseTo(impulse = 1, directionDim = 0) {
                let i = directionDim === 0 ? this.firstText.length - 1 : 0;
                let j = directionDim === 0 ? this.secondText.length - 1 : 0;
        
                let temperature = Math.max(0, Math.min(this.thermometerWidth - 1, (this.thermometerWidth - 1) * impulse));
                let measurements = [];
        
                let matchedText1 = "";
                let matchedText2 = "";
                while (i >= 0 && j >= 0) {
                    let charPositionI = directionDim === 0 ? i : (this.firstText.length - i - 1);
                    let charPositionJ = directionDim === 0 ? j : (this.secondText.length - j - 1);
        
                    if (this.firstText.charAt(charPositionI) === this.secondText.charAt(charPositionJ)) {
                        measurements.push(0);
                        matchedText1 = this.firstText.charAt(charPositionI) + matchedText1;
                        matchedText2 = this.secondText.charAt(charPositionJ) + matchedText2;
                        temperature = Math.min(temperature + (this.options.heating || 1), this.thermometerWidth - 1);
                        i--;
                        j--;
                        continue;
                    }
        
                    let tDirection = directionDim === 0 ? -1 : 1;
                    const transversal = (i >= 1 && j >= 1) &&
                        (this.firstText.charAt(charPositionI + tDirection) === this.secondText.charAt(charPositionJ) &&
                         this.firstText.charAt(charPositionI) === this.secondText.charAt(charPositionJ + tDirection));
        
                    if (transversal) {
                        measurements.push(0);
                        matchedText1 = this.firstText.charAt(charPositionI) + this.firstText.charAt(charPositionI + tDirection) + matchedText1;
                        matchedText2 = this.firstText.charAt(charPositionJ) + this.secondText.charAt(charPositionJ + tDirection) + matchedText2;
                        i -= 2;
                        j -= 2;
                    } else if (this.dp[i + 1][j][temperature][directionDim] <= this.dp[i][j + 1][temperature][directionDim]) {
                        measurements.push(this.thermometerWidth - temperature);
                        matchedText2 = `-` + matchedText2;
                        temperature = Math.max(temperature - (this.options.cooling || 1), 0);
                        j--;
                    } else {
                        measurements.push(this.thermometerWidth - temperature);
                        matchedText1 = '-' + matchedText1;
                        temperature = Math.max(temperature - (this.options.cooling || 1), 0);
                        i--;
                    }
                }
        
                return {
                    matchedText1,
                    matchedText2,
                    measurements
                };
            }
        
            traverse(impulse = 1) {
                const ltr = this.traverseTo(impulse, 0);
                const rtl = this.traverseTo(impulse, 1);
                return {
                    ltr,
                    rtl
                };
            }
        
            distance(impulse = 1, direction = 'ltr') {
                const startOn = Math.max(0, Math.min(this.thermometerWidth - 1, (this.thermometerWidth - 1) * impulse));
                return this.dp[this.firstText.length][this.secondText.length][startOn][direction === 'ltr' ? 0 : 1];
            }
        
            maxDistance(impulse = 1) {
                let maxDistance = 0;
                let temperature = Math.max(0, Math.min(this.thermometerWidth - 1, (this.thermometerWidth - 1) * impulse));
        
                for (let i = 0; i < (this.firstText.length + this.secondText.length); i++) {
                    maxDistance += this.thermometerWidth - temperature;
                    temperature = Math.max(temperature - (this.options.cooling || 1), 0);
                }
        
                return maxDistance;
            }
        
            similarityTo(impulse = 1, direction = 'ltr') {
                return 1 - this.distance(impulse, direction) / this.maxDistance(impulse);
            }
        
            similarity(impulse = 1) {
                return Math.max(this.similarityTo(impulse, 'ltr'), this.similarityTo(impulse, 'rtl'));
            }
        
            localSimilarity(impulse) {
                function standardDeviation(measurements) {
                    let mean = measurements.reduce((prev, curr) => prev + curr, 0) / measurements.length;
                    return Math.sqrt(measurements.reduce((prev, curr) => prev + Math.pow(curr - mean, 2), 0) / (measurements.length - 1));
                }
        
                const { ltr, rtl } = this.traverse(impulse);
        
                const similarity1 = this.similarityTo(impulse, 'ltr');
                const similarity1W = 1 - Math.abs(0.5 - similarity1) / 0.5;
                const standardDeviation1W = standardDeviation(ltr.measurements) * Math.pow(similarity1W, 2);
                const localSimilarity1 = Math.min(1, similarity1 / Math.max(1, standardDeviation1W));
        
                const similarity2 = this.similarityTo(impulse, 'rtl');
                const similarity2W = 1 - Math.abs(0.5 - similarity2) / 0.5;
                const standardDeviation2W = standardDeviation(rtl.measurements) * Math.pow(similarity2W, 2);
                const localSimilarity2 = Math.min(1, similarity2 / Math.max(1, standardDeviation2W));
        
                return Math.max(localSimilarity1, localSimilarity2);
            }
        }

    </script>
</body>

</html>
